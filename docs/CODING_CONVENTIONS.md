# Coding Conventions

## Naming Conventions

- `UPPER_SNAKE_CASE`
  - マクロ名
  - 列挙子名 (`enum`)
- `UpperCamelCase`
  - 型名
  - 列挙子名 (`enum class`)
- `_lowerCamelCase`
  - privateメンバ変数名
  - privateメンバ関数名
- `lowerCamelCase`
  - 変数名
  - 関数名

## Tabs for Indentation

インデントにはタブ文字を用いる。

## 120 Column

原則1行最大120文字。
タブ文字のせいで一見すると120文字を超えていることもあるが、面倒臭いので無視。

## auto

`auto`が使えるなら使う。

## const

`const`が使えるなら使う。

## No namespace Indentation

`namespace`ブロックはインデントしない。
凄く気持ち悪いけど仕方ない。

## enum class

`enum`の代わりに`enum class`を用いる。

## pragma once

Include guardの代わりに`#pragma once`を書く。

## Namespace Base Directory

名前空間に即してディレクトリ構成を行う。

## No Legacy Code

API部分を除いてC由来のレガシーなコードを書かない。

## Concise Code

コードは負債である。
結果が変わらない限り、コード量は少ない方が良い。
とはいえ、コード量を減らすことだけに注力して、ifを一行にしたり、関数名を省略したりすると、かえって可読性が落ちる。
あくまで、ヒューマンエラーを減らすためにコード量を減らしていることに注意する。

## Global Variables

グローバル変数を禁止しない。

グローバル変数にはどこからでも参照できるという害悪性がある。
しかし、classのprivateメンバとて、class内のどこからでも参照できる。
とすると、グローバル変数をファイルスコープに閉じ込めてしまえば良い。
C/C++ではどこかで定義された変数をexternを使うことで公開できるが、これを禁止する。
C/C++では別のファイルで同名の変数を定義すると名前衝突を起こすが、適切に名前空間を与えることでこれを回避する。
そうすることで、変数をファイルスコープにカプセル化できる。
つまり、一ファイルを一classと見なせる。
classではなくなったことで、冗長なclassの構文を回避でき、コード量を削減できる。

グローバル変数にはインスタンスが単一であるという害悪性がある。
例えばVulkanはインスタンスハンドルを介して状態を操作することで、複数のインスタンスを作成できるようにしている。
グローバル変数は同じメモリを使いまわすため、これを実現するには配列化しなければならない(そして、そんなことはしたくない)。
しかし、すべてのオブジェクトが複数インスタンスの作成を期待するわけではない。
むしろ、それを期待すると、インスタンスの管理の手間が生じる。
つまり、コード量が増える。
であれば、インスタンスが単一であるならば、わざわざclassにカプセル化する必要もなければ、そうしない方が良い。
orgeがVulkanに倣う必要はない。
orgeはプロセス=ゲームを期待するゲームエンジンである。

グローバル変数には不変性を保障できないという害悪性がある。
classはコンストラクタのおかげで、メンバを不変にでき、メンバが既に初期化されていることをメソッドが期待できる。
またclassはメンバ関数には`const`を付し、メンバ関数が状態を変更しないことを期待できる。
正直、これはとても魅力的な機能である。
しかし、保障されているのはあくまで不変であることと副作用がないことだけである。
言い換えれば、破壊的変更を書いたときにコンパイルエラーになるとか、メンバ関数の呼出し元が安心できるとか、その程度の話である。
それに、orgeのAPIの殆どは副作用があって当然のものである。
とすれば恩恵の範囲はorgeの開発者に限る。
その恩恵のために多くのコードを書かなければならないならば、悩ましくもなる。
ファイルを流し読みしても破壊的変更に気づけるほどファイルを小さくすれば良いとも言える。
